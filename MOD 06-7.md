# MODULE 6

## Command Shell & Batch Files

### IOC's
<img width="1950" height="1630" alt="image" src="https://github.com/user-attachments/assets/081d663a-9a85-4170-92c4-ab9f37f4c229" />

### Windows CMD Shell
- CMD has several built-in commands, such as dir (lists the current directory), cd (changes directory), as well as the ability to run executable binaries
- The CMD CLI application provides an interface to the OS
- The processes ConHost.exe and CMD show as running processes; ConDrv.sys is the Windows kernel driver that provides the communication infrastructure between ConHost and one or more CLI applications.

### Batch Files
- Windows originally used batch files as a way to perform a set batch of saved commands
- These commands are executed non-interactively as a script that has some conditional flow control to branch which commands are executed under specific circumstances
- Batch files contain Windows commands along with some flow control and comparison operators that are saved in a text file with a .bat or .cmd extension
- The .cmd extension was introduced with the Windows NT family of OSs and were executed with CMD instead of the older COMMAND.COM.
- COMMAND.COM is no longer included on Windows OSs and CMD executes both .bat and .cmd files as batch scripts.
- Batch files are plain text files most commonly edited in notepad.exe.

### Variables
- Variables in batch files are case-sensitive and are assigned using the set command.
- Variables from an interactive CMD session are case-insensitive.
- Often localized variables in a batch file use lowercase variable names while system-wide environmental variables are uppercase
- The set command does not check to see if a variable already exists; it holds data
- Variables are read by surrounding the variable name with the % operator
- To set a variable, the set command is used, and using an environment variable involves surrounding it with % to indicate that it is a variable
- Generally, the setx command should only be used when permanently altering the environment variable is desired.
- The setx command operates off the current user, rather than system environment variables by default
  <img width="1950" height="1180" alt="image" src="https://github.com/user-attachments/assets/ea0d93bc-5676-4ba1-9b13-49cd7569c2d1" />

### Loops and Conditionals
- The basic structure of the if command is:
      ``if [NOT] condition (command) [else (command)]
        if [NOT] ERRORLEVEL number (command)
        if [NOT] string1==string2 (command)
        if [NOT] EXIST filename command
      ``
- not: Specifies that the command to be executed initiates if the condition is false.exist: Checks for the existence of a file or directory. In order to ensure the tested value is a directory and not a file, checking for a device file, such as NULL, may be used (e.g., exist “C:\NewFolder\NULL”)errorlevel: Compares the last returned errorlevel against a specified value. For example, errorlevel 0 checks for a return value of 0 (by convention, no error returned from the previous command). The error level may not be reset on some built-in commands if .bat files are used.string1==string2: Checks if the two string values are the same (e.g., %COMPUTERNAME%=="SYSTEM1” checks if the computer’s name is SYSTEM1).string1 OPERATOR string2: Compares the two values using the three letter operator:EQU: Equal toNEQ: Not equal toLSS: Less thanLEQ: Less than or equal toGTR: Greater thanGEQ: Greater than or equal to

- `if not exist "C:\NewFolder\NULL" mkdir "C:\NewFolder"`

### FOR Statement
- `for %variable IN (set) DO command [command-parameters]`
-  The for command is used to iterate each item in a set and perform some action/command.
-  The variable used as the iterator — %variable in the above command outline — is a single character in the range a-z or A-Z, and is referenced as %%a or %%Z (%%z and %%Z are different variables).
-  The use of the extra % operator is used in batch files and not from the CLI (where it is a single %).
-  The various types of iterations are based on the switches below:
  - /l: Series of values
  - /f: Series of files
  - /d: Series of directories
  - /r: Each item in a directory tree
- `for /l %%variable in (start,step,end) do (command)`
- `for /l %%A in (0,2,10) do echo %%A`
- two percent signs are used for BATCH FILES and single is used in CLI.
- Looping through directories, recursively: `for /r "%USERPROFILE%" %%D in (*) do echo %%D`
- Looping through directories for .bat files recursively: `for /r "%USERPROFILE%" %%D in (*.bat) do echo %%D`
- Parsing File Content and Output: `for /f ["options"] %%variable in (source) do (command)`
  - `@echo off
      for /f "tokens=1-4" %%A in (hosts.txt) do ( echo host: %%A IP Address: %%B Department: %%C Email: %%D)`

### GOTO Statements
- Batch files support labels and the goto operand for program flow
- Labels are specified by giving the label name preceded by :
- The goto command is followed by the label specifying a location in the batch file to start executing instructions from next, which is a way to control the order in which instructions are executed.
  ```
  @echo off
  if "%1"=="" (echo Error: No arguments) & (goto EXIT)
  if "%1"=="1" goto SUBROUTINE1
  if "%1"=="2" goto SUBROUTINE2
  if "%1"=="3" goto SUBROUTINE3
  goto EXIT
  
  :SUBROUTINE1
  echo This is subroutine 1
  goto EXIT
  
  :SUBROUTINE2
  echo This is subroutine 2
  goto EXIT
  
  :SUBROUTINE3
  echo this is subroutine 3
  goto EXIT
  
  :EXIT
  echo exiting...
  ```

### Powershell
- PowerShell is a CLI shell and scripting language designed specifically for system administration
- PowerShell has a rich expression parser and a fully developed scripting language
- The PowerShell Integrated Scripting Environment (ISE) is a host application for PowerShell
- In PowerShell ISE, you can run commands and write, test, and debug scripts in a single Windows-based GUI with multiline editing, tab completion, syntax coloring, selective execution, context-sensitive help, and support for right-to-left languages.
- PowerShell ISE allows users to utilize menu items and keyboard shortcuts to perform many of the same tasks that are executed in the Windows PowerShell console.
- to set a line breakpoint in a script, right-click the line of code, and select **Toggle Breakpoint**.
- Cmdlets are similar to Windows commands, but provide a more extensible scripting language
- Powershell Features
  - Cmdlets: Cmdlets perform common system administration tasks such as managing the registry, services, processes, event logs, and using Windows Management Instrumentation (WMI).
  - Task-oriented: PowerShell scripting language is task-based and provides support for existing scripts and CLI tools.
  - Consistent design: As cmdlets and system data stores use common syntax, and have common naming conventions, data sharing is easy. The output from one cmdlet can be pipelined to another cmdlet without manipulation.
  - Simple to use: Simplified, command-based navigation lets users navigate the registry and other data stores similar to the file system navigation.
  - Object-based: PowerShell possesses powerful object manipulation capabilities. Objects can be sent to other tools or databases directly.
  - Extensible interface: PowerShell is customizable as independent software vendors and enterprise developers can build custom tools and utilities using PowerShell to administer their software.
- Cmdlet vs Command
  - Cmdlets are .NET Framework class objects; not just stand-alone executables.
  - Cmdlets are easily constructed from as few as a dozen lines of code.
  - Parsing, error presentation, and output formatting are not handled by cmdlets. It is done by the PowerShell runtime.
  - Cmdlets process works on objects not on text stream, and objects can be passed as output for pipelining.
  - Cmdlets are record-based as they process a single object at a time.

#### SYNTAX
- Create a new Directory: `New-Item -Path 'C:\users\trainee\temp' -ItemType Directory`
- Copy a folder to a new folder: `Copy-Item 'C:\users\trainee\temp' 'C:\users\trainee\temp2'`
- Remove an Item: `Remove-Item 'C:\users\trainee\temp2'`
- Check for existance of a folder: `Test-Path 'C:\users\trainee\new_temp'

### Powershell Scripts
- PowerShell scripts are stored in .ps1 files
- A user can check this policy by running the Get-ExecutionPolicy command in PowerShell:
- The Get-ExecutionPolicy command returns one of the following values:
  - **Restricted**: No scripts are allowed (individual commands are still permitted). This is the default setting for workstations and client systems; it appears the first time the command is executed.
  - **AllSigned**: Run scripts signed by a trusted developer. With this setting in place, before executing, a script confirms that you want to run it.
  - **RemoteSigned**: Run your own scripts or scripts signed by a trusted developer. This is the default policy for servers. Scripts running remotely or those downloaded from the internet still must be signed by a trusted publisher.
  - **Unrestricted**: Run any script you want.
- Cmdlet Format
  - A cmdlet always consists of a **verb** (or a word that functions as a verb) and a **noun**, separated with a hyphen (the verb-noun rule).
  - Some of the most common verbs include:
    - **Get**: To get something
    - **Set**: To define something
    - **Start**: To run something
    - **Stop**: To stop something that is running
    - **Out**: To output something
    - **New**: To create something (new is not a verb, of course, but it functions as one)
  <img width="680" height="295" alt="image" src="https://github.com/user-attachments/assets/24006f88-8304-4c51-94ab-18a9929104e9" />


## BASH

### Intro to Bash
- Bash is an interpreter that executes commands from an interactive interface, from standard input, or from a file
- Bash is also known as the GNU (GNU not Unix) Bourne-Again Shell as it is fully compatible with the previous standard Bourne shell sh.
- Bash provides a standard environment to execute built-in commands or other commands provided by the OS on which it is running
- Not every system has a Graphical User Interface (GUI) so it is important that analysts and defenders have the ability to efficiently navigate and use text-based terminal shells
- Remote access and configuration is also often done over a text-based terminal through a secure terminal session via programs like Secure Shell (SSH).
- The ability to link commands and run them in scripts make shells like Bash extremely useful in sifting through large amounts of data and pulling out the pieces that are important to the analyst or defender.
- Since Bash is interpreted, the same commands run interactively from a command prompt can be saved into a file as a script to be run at a later date, or perform automated or complex operations repeatedly
- Unix/Linux OSs typically employ a shell for users as their login environment and to interact with the system.
- Bash is also invoked to execute commands non-interactively, or as a subshell of Bash or another shell.
- When a user logs into a Linux system that has the user’s login shell set to Bash, one of the system processes starts Bash in the context of the user’s profile, which includes user system accesses and security permissions
- There are also files that are read/executed when the shell exits normally.
- This is useful to set things like the default PATH variable for login shells.
- **Inserting commands or scripts into these files is one of the ways Malicious Cyberspace Activities (MCA) execute files in the context of another user, maintain persistence, or harvest credentials**
  <img width="776" height="206" alt="image" src="https://github.com/user-attachments/assets/9df21c3a-3461-4c98-bb82-3b9243ce4f3f" />
  <img width="775" height="376" alt="image" src="https://github.com/user-attachments/assets/b1a49084-2222-442f-a5f9-aec384d3665b" />
- When Bash is started as an interactive shell that is not a login shell, the file ~/.bashrc is the only file that is read, unless the -norc option is sent to the shell to not read the ~/.bashrc file
- when Bash is started non-interactively, it inherits the contents of the $BASH_ENV variable, if it exists
- Z shell, or zsh, is very similar to Bash in that it is backwards compatible with the Bourne shell (sh) and has many of the same capabilities as Bash, but uses different files and additional/alternate environment variables
  <img width="768" height="555" alt="image" src="https://github.com/user-attachments/assets/9699ebbf-3873-4a85-940e-773dbe25553a" />

## BASH PROMPT
- A $ indicates a non-root (user Identifier [ID] other than 0) user and a # indicates commands are executed with root (user ID of 0) privileges.
- The standard prompt is set in the PS1 variable and seen with the echo $PS1 command.
  <img width="970" height="783" alt="image" src="https://github.com/user-attachments/assets/9100997e-f1d8-4c5a-af95-b5d82b272cff" />

- The following example shows the full current working directory and the time in 24-hour format (HH:MM:SS):
  - ```PS1="[\u@\h \w \T]\\$ "```
 
### Parameters
- **Parameters** are containers that store values including a name, a number, or a special character.
- A **variable** is a container that has an associated name and is declared using the format `name=value`
- Bash has several parameters that have special meanings or expansions. Some of the most common expansions include:
  <img width="550" height="800" alt="image" src="https://github.com/user-attachments/assets/a0cbd627-e7a6-49bb-ae31-4c91b267bf26" />

- Bash keeps a history containing a list of commands run from an interactive shell
- The number of commands saved is controlled by the **HISTSIZE** variable and defaults to 500 commands
- The **HISTCONTROL** and **HISTIGNORE** variables are set to not save commands that are duplicates or are prefaced with the characters described in the variable
- The options are **ignorespace** and **ignoredup**, or **ignoreboth** to set both options.
- To add ignorespace to the HISTCONTROL variable, enter the command:
  - ```HISTCONTROL=$HISTCONTROL:ignorespace```
- Bash history expansion is a powerful feature that allows a user to refer to a previous command without having to enter the entire command again. Some common history expansions are:
  <img width="963" height="503" alt="image" src="https://github.com/user-attachments/assets/3ce191ad-1cb3-4380-883f-0c5cde120df1" />

### Re-Introduction to VI/Vim
- It uses the same basic functions as Vi but allows for enhanced features like syntax highlighting, external plugins, multi-level undo/redo, screen splitting for editing multiple files, and other features documented on the Vim manual page
- Vim has two main modes: command mode (default) and insert-text mode
  
### MAN PAGES
- There may be multiple manual pages for the same object if it is used in different sections
- To open a manual page from a specific section, use the format man n command where n is the section number of the desired manual page
-  The spacebar or CTRL+F advances the manual one page at a time, CTRL+B moves back one page at a time, gg moves to the start of the manual, SHIFT+G moves to the end of the manual, /STRING searches for the next occurrence of the text after the slash, and Q exits the manual.
  <img width="963" height="563" alt="image" src="https://github.com/user-attachments/assets/c4cf5ad6-49e4-4aae-a97d-231466fbf684" />

### CHMOD
<img width="963" height="455" alt="image" src="https://github.com/user-attachments/assets/ef47d1c6-8f01-4860-ac03-32c74a036dde" />
<img width="963" height="337" alt="image" src="https://github.com/user-attachments/assets/9c89c533-56cb-4a7e-9efa-43d9ef04676c" />
- ```chmod u+x <script>```

### Standard Input, Standard Output, and Standard Error
<img width="963" height="236" alt="image" src="https://github.com/user-attachments/assets/ad5da30d-1f0f-480c-bc00-2ca4b65b0ae2" />
- Typically for Linux-based systems, a special memory-based filesystem is mounted containing information on all the processes running on the system, including the FDs the program has opened and is mounted as /proc.
- There are three standard files, also called streams, that are associated with input and output for programs: **/dev/stdin**, **/dev/stdout**, and **/dev/stderr**.
- Streams have two ends, a source and a destination like a water hose or a pipe, and contain data.
- Two additional Special Files
  <img width="963" height="384" alt="image" src="https://github.com/user-attachments/assets/db45ec98-66ba-497f-bbe9-679d1a6eaeb2" />

  <img width="963" height="786" alt="image" src="https://github.com/user-attachments/assets/981ee8a7-a434-46cb-b63d-770b8ac55e1c" />

### List of Commands

<img width="613" height="471" alt="image" src="https://github.com/user-attachments/assets/e9a4dd97-1b3a-4ac4-b4cc-393a2ce0e9d9" />


## Windows Management Instrumentation (WMI)

### Current Events
- As WMI is used by system administrators for remote configuration and management, MCAs have used the same infrastructure and Application Programming Interfaces (API) to perform discovery, gain execution, and assist in lateral movement.
- MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK) identified WMI abuse as execution technique T1047.
- In particular, the threat group identified by FireEye Threat Research as UNC2452 used WMI abuse as part of their SUNBURST backdoor to enumerate the installed drivers in late 2020 and early 2021.

### WMI Architecture
- WMI is a valuable tool for system administrators to aid in configuring local and remote Windows systems, but it is also frequently abused by threat actors during MCAs.
- Threat actors continue to use WMI to aid in discovery and remote execution as a part of lateral movement.
- **WMI relies on the WMI service for local/remote access, Server Message Block (SMB), and Remote Procedure Calls (RPC), over Transmission Control Protocol (TCP) port 135, to function. Put simply, this means WMI uses TCP port 135 to initiate communication with the remotely managed host, then switches to any random high port anywhere between TCP port 1024-65535.**
- Some of the data threat groups can gain from using WMI include obtaining a list of all domain administrators, identifying any installed antivirus software, and listing all the running processes.
- WMI abuse is mitigated by managing administrator accounts and access, and through credential reuse prevention.
- WMI services are accessed using a variety of tools and APIs, most commonly using the WMIC.exe command line utility and PowerShell.

### Detection
- WMI abuse is detected by monitoring network traffic for the use of WMI connections, where not permitted by policy, and process monitoring of the WMIC utility to capture command line arguments — WMIC commands — that are specifically targeted for remote systems
- PowerShell logging is configured using group policy under Administrative Templates > Windows Components > Windows PowerShell.
- Windows has native logging of WMI events, but it is not enabled by default and does not show the WMI classes being queried in a friendly manner.
- There are two main options to add WMI event logging/tracing:
  - using the Event Viewer graphical application,
  - and the wevtutil.exe command line program
- Understanding where WMI is normally being used by system administrators is important as most systems do not normally use significant WMI resources.
- Detecting where WMI is being used and during which normal times may assist in identifying malicious WMI activity.
- Other methods of detecting WMI use and abuse is found in the logging of the results of their actions

## WMI Architecture
- WMI consists of three main components:
  - WMI providers and the associated managed objects,
    - Consist of a Dynamic Linked Library (DLL) and an associated Managed Object Format (MOF) file that define the managed objects, and provide the interface for retrieving data or performing functions — or methods — on those objects.
    - Some of the common WMI providers installed by default are:
      <img width="968" height="913" alt="image" src="https://github.com/user-attachments/assets/3edff14b-9d40-474a-aa23-82c71e30f914" />
      - **CLASS = OBJECT**
  - WMI infrastructure,
    - WMI service — winmgmt — is the system component known as WMI Infrastructure.
    - This service has two components:
      - Common Information Model (CIM) Object Manager (COMOM) or WMI Core,
      - and the WMI (also known as the CIM) Repository.
      - The WMI repository is organized by hierarchically defined namespaces starting with root
      - Some of the namespaces created by the WMI service on system startup are the **root\default** and **root\cimv2** namespaces
      - The WMI service handles the requests from the management applications and the WMI repository and providers
  - WMI consumers or management applications such as WMIC and PowerShell
    -  A management application, like WMIC and PowerShell, that sends requests to the WMI service.
    -  Management applications query data, enumerate data, execute provider methods, and subscribe to events using the appropriate API.
    -  Applications only access the objects and methods that a WMI provider has defined and can handle.
- The implementation of WMI provides a consistent standard framework for interacting with various objects and management data.
- The WMI API converts the standard interface into the various system and library calls associated with the specific providers handling the managed objects.
  <img width="700" height="585" alt="image" src="https://github.com/user-attachments/assets/8152c2f5-3ed4-4bc5-b16b-0743a96b4fe4" />

### WMI Consumers
- WMI Explorer is a Graphical User Interface (GUI)-based tool that makes it easy to enumerate the various namespaces, classes, and instances as well as the associated methods and properties associated with those instances.
  <img width="1215" height="719" alt="image" src="https://github.com/user-attachments/assets/f9601845-279a-4d98-b39e-07e53dd17a48" />

- The WMIC utility is a CLI for dealing with Windows's WMI providers through the WMI Infrastructure APIs provided for management applications.
  - The format for the WMIC command is:
    - ```wmic [global switches] <command>```
-  Table 6.3-2 describes the global switches. The switches and commands are not case sensitive, but are displayed in various cases for readability.
    <img width="966" height="2702" alt="image" src="https://github.com/user-attachments/assets/2917c72a-3c77-4b39-8d3b-5341f5cd0512" />
    - **/NAMESPACE**: will be CIMV2
    - To remotely run WMIC:
      - **/NODE**
      - **/USER**
      - **/PASSWORD**
- WMIC Aliases
  - These are listed by entering wmic /? at a command prompt
  - When using aliases, the format of the WMIC command is in one of the following:
    - ```wmic <alias> [WMIObject]```
    - ```wmic <alias> [<path where>]```
    - ```wmic <alias> [<path where>] [<verb clause>]```
  - Usage:
    - ```wmic <alias> ASSOC [<format specifier]>```
    - ```wmic <alias> CALL <method name> [<parameter list>]```
    - ```wmic <alias> CREATE <assignment list>```
    - ```wmic <alias> DELETE```
    - ```wmic <alias> GET [<property list>] [<get switches>]```
    - ```wmic <alias> LIST [<list format>] [<list switches>]```
    - ```wmic process list brief```
    - ```wmic process where processid=2564 call getowner```
    - ```wmic process where name="notepad.exe" list breif```
    - ```wmic process where name="notepad.exe" get /all /format:list```
    - ```wmic process where processid=2564 call terminate```
- The following two commands returns the same information, the first specifying the namespace and class, and the second using only the PATH
  - ```wmic /namespace:\\root\cimv2 path win32_account get /all /format:list```
  - ```wmic path win32_account get /all /format:list```
- The Win32_Account class contains both system accounts and user accounts
- WMIC has an alias for each type of account, so in order to retrieve the same information as in the previous commands, two aliases commands must be run:
  - ```wmic sysaccount get /all /format:list```
  - ```wmic useraccount get /all /format:list```
- Table 6.3-3 describes some of the WMIC aliases used by analysts and defenders
  <img width="512" height="668" alt="image" src="https://github.com/user-attachments/assets/fd33c11b-cf56-4166-a0a5-f2a4d21af40c" />
  - **rdtoggle**: REMOTE DESKTOP PROTOCOL (RDP)

### WMIC Where Clauses
- WMIC Where clauses allow filters to be applied to the WMIC command being executed. An example of filtering the services for only svchost.exe is:
  - ```wmic process where ”Name like 'svchost%'” get name,processid,parentprocessid,commandline```
- The percent symbol is used as a wildcard to filter processes where the Name property starts with svchost.
- The operators and wildcards that are available for Where clauses are in the table below.
  <img width="965" height="823" alt="image" src="https://github.com/user-attachments/assets/3b2fd15b-a587-47f2-b171-61290430ff53" />
  
### Powershell and WMI
- Unlike most shells that only accept and return text, PowerShell accepts and returns .NET objects
- PowerShell provides this capability through various cmdlets such as Get-CIMInstance
- While PowerShell's built-in cmdlets and .NET objects are powerful  — and all that is normally needed — the ability to query WMI objects is sometimes required to retrieve all the necessary data.
- The simplest form of interacting with WMI from PowerShell is to start a PowerShell shell from the start menu and use Get-CIMInstance from the prompt:
  - ```Get-CIMInstance -ClassName Win32_Process```
  - ```Get-CIMInstance -ClassName Win32_Process | Get-Member```
  - ```Get-CIMInstance -ClassName Win32_Process | Format-Table -Property ProcessName, Caption, ProcessID, CommandLine```

### Use WMIC to Enumerate Network- and Remote Desktop-Related Services
- ```wmic process where processid=2564 call terminate```
- ```wmic nicconfig where index=0 call flushdns```
- ```wmic service list brief```
- ```wmic service where name="TermService" list /format:list```: **Queries status of TermService service, which deals with RDP**
- ```wmic service where name="TermService" call ChangeStartMode "Disabled"``` **Disables RDP**


# MODULE 7

## PowerShell Objects, Properties, and Methods

### Overview
- PowerShell scripting is greatly enhanced by producing your own classes, properties, and methods.
- Classes can be instantiated to produce objects - though, these are not the only types of objects in PowerShell.
- Objects in PowerShell include:
  - **Classes**
    - Classes are objects defined by code with concrete properties and methods
  - **PSCustomObject**
  - **Hashtables**
- The latter two types of objects are dynamic and may contain any property — they are only distinguished by convention.
- The type system used by **PSCustomObject** and **Hashtables** is referred to as **_Duck Typing_** — if it behaves, looks, and sounds like an object of the specified type, then it is that type.

- PowreShell Classes
  - PowerShell version 5.0 and above include native syntax for classes, which contains methods and properties.
  - PowerShell’s class syntax begins with a simple class declaration:
    ```
    class ClassName {

    {
    ```
  - A class declaration begins with the class keyword, followed by the class name and a code block, indicated by braces.
  - Methods are defined within a class — a simple method declaration follows:
    ```
          [String]SayHello([String]$name){
          Return ("Hello " + $name + "!")
      }
    ```
  - To find out more about PowerShell classes, use the Get-Help command:
    - ` Get-Help about_Classes`


## Remote Endpoint Interaction

### Interacting with Artifacts
- File Hashing
  - During the course of duties, situations occur that require the hashing of files — such as comparing artifacts against databases or compiling information for reports
  - intelligence briefings often include hashes of known artifacts associated with a particular malware; validating their presence is part of the analyst’s responsibilities.
  - PowerShell hashes files or other artifacts natively via the **Get-FileHash** cmdlet
  - The Get-FileHash cmdlet uses these arguments:
    - **Algorithm**: Hashing algorithm to use, such as Message Digest 5 (MD5), Secure Hashing Algorithm 1 (SHA1), or Secure Hashing Algorithm 256 (SHA256)
    - **Path**: Path to the file to be hashed; accepts wildcards to evaluate multiple files or an array of strings
  - The first unnamed parameter is inferred to be the Path argument (e.g., Get-FileHash example.txt).

- .NET Encoding Classes
  - Red teams and blue teams alike benefit from using various encoding methods, such as Base64 encoding, to perform their tasks
  - In addition to Base64 encoding, .NET contains classes for converting between various text-encoding types, such as American Standard Code for Information Interchange (ASCII), Unicode Transformation Format – 8-bit (UTF-8),
  - Use the [Convert]::ToBase64String and [Convert]::FromBase64String methods with one parameter for each (in these examples):
    - [Convert]::ToBase64String(byte[])
      - byte[]: Byte array (binary data) converted to a Base64 string
      - returntype: String containing the Base64 encoded data
    - [Convert]::FromBase64String(string)
      - string: String converted to a byte array (binary data)
      - return type: Byte[] containing the converted data

### Working with Artifacts
- Hashing a single file is accomplished using the **Get-FileHash** cmdlet.
- This cmdlet performs a file hash and returns an object containing the results, which PowerShell formats and displays to Terminal.
- Encoding .NET Classes

### Utilizing PSProviders
- PowerShell Providers (PSProviders) interact with databases or other data structures in a manner very similar to a filesystem, querying and navigating the underlying data using concepts of files and folders, much like a filesystem.
- The FileSystem PSProvider interacts with the filesystem in PowerShell using cmdlets like Get-ChildItem.
- Analysts use these PSProviders to search for artifacts (such as autorun entries) to detect persistence or unusual path environment variable entries used in library preference order attacks.
- Use the following cmdlets in this exercise:
  - Get-Item: Retrieves an object containing information about a particular item supplied by a PSProvider; uses the following parameter:
    - Path: Location of the item; accepts wild cards, and inferred as the first unnamed parameter (e.g., Get-Item C:\Windows\System32\Hosts)
  - Get-ChildItem: Lists all items in a specified or current directory; uses the following parameter:
    - Path: Location of the directory to be enumerated; inferred from the first unnamed parameter (e.g., Get-ChildItem C:\Windows\System32)
  - New-Item: Creates a new entry in the specified location; uses the following parameters:
    - Path: Location of the item to be created (i.e., directory/folder/drive)Name: Name of the item to be createdValue: Initial value of the new item
  - Move-Item: Moves an item to a specified location; uses the following parameters:
    - Path: Location of the file to be moved; inferred from the first unnamed parameter Destination: Destination filename; inferred from the second unnamed parameter
  - Set-Item: Replaces the contents of a specified item with a new value; uses the following parameters:
    - Path: Path of the item to have its value changedValue: New item value
  - Remove-Item: Deletes the specified item; uses the following parameter:
    - Path: Path of the item to be removed; inferred from the first unnamed parameter
  - Rename-Item: Renames a specified item; uses the following parameters:
    - Path: Path of the item to be renamed; inferred from the first unnamed parameter NewName: New item name
  - New-PSDrive: Maps a new PowerShell Drive (PSDrive) — used to simplify paths; uses the following parameters:
    - Name: New drive name; addressable via Name:PSProvider:
  - PSProvider that the PSDrive operates under
    - Root: Root path that the PSDrive operates under
  - Get-PSProvider: Displays all available PSProviders


### Interacting Remotely using powershell
- Many remote commands require Windows Remote Management (WinRM) — including those used within this lesson — to be configured on the remote computer, as well as a host trusted by the local computer.
- Security implications exist with the usage of PowerShell Remoting, especially with potentially compromised machines or networks
- Depending on the method of authorization, the identity of the remote machine may not be validated — especially if Trusted Hosts is used to bypass verification.
- In addition, compromised machines often intercept credentials or authentication hashes.
- For this module, use the following commands:
  - Get-Credential: Stores credentials after prompting for them; used with commands that require them, such as Invoke-Command or New-PSSession
  - Invoke-Command: Runs a code block or script file on the local or a specified remote machine; uses the following parameters:
    - Credential: Created via Get-Credential; used to connect to the remote computer
    - ComputerName: Name of the computer to run commands on; accepts multiple computer names; must be resolvable via Domain Name System (DNS) or other name lookup
    - ScriptBlock: Block of code to be run
    - FilePath: File containing the script to be run
    - Session: Session to invoke a command on (exclusive with ComputerName)
  - New-PSSession (PowerShell Session): Creates a reusable session with the remote computer(s), variables, etc. on the remote session to be saved for the duration of the session.
    - Credential: Created via Get-Credential; used to connect to the remote computer
    - ComputerName: Name of the computer to run commands on; accepts multiple computer names; must be resolvable via DNS or other name lookup
  - Invoke-WebRequest: Useful for interacting with web servers. For this lesson, used to download files via the PowerShell terminal.
    - URI (Uniform Resource Identifier): Location of the file to be downloaded, e.g. _**http://speedtest.tele2.net/10MB.zip**_
      - Megabyte (MB)
    - OutFile: File to be written
    - Credential: Created by Get-Credential, used to authenticate with the remote server for this request
  - Start-BitsTransfer: Uses Background Intelligent Transfer Service (BITS) on Windows environments to download a file
    - Source: Location of the file to be downloaded, e.g. http://speedtest.tele2.net/10MB.zip
    - Destination: File to be written
    - Credential: Created by Get-Credential, used to authenticate with the remote server for this request
    - Asynchronous: Specifies whether or not a file is downloaded interactively
  - Get-BitsTransfer: Lists active download jobs for BITS

## Bash Scripting

### Compound Commands
- A compound is a command executed in a subshell environment, executed in the current shell environment, executed in a group, evaluated as an arithmetic expression, evaluated as a conditional expression, or a series of commands executed within several flow control constructs.
- Multiple commands are separated by a semicolon, and any command that has the ampersand (&) associated with it is executed in the background (asynchronously) while the next command is started before waiting for the background command to finish
  <img width="969" height="1162" alt="image" src="https://github.com/user-attachments/assets/98e18456-f2bd-4431-a942-1d495560593c" />

- Bash has an environment variable BASH_SUBSHELL, which increments each time a subshell is invoked

  ```
  trainee@cda-lin-hunt:~$ (echo $BASH_SUBSHELL); echo $BASH_SUBSHELL
  trainee@cda-lin-hunt:~$ (echo "First: $BASH_SUBSHELL"; (echo "Second: $BASH_SUBSHELL")); echo "Third: $BASH_SUBSHELL"
  ```
- When the same type of command is formatted as a list, they must be terminated by semicolons and separated by spaces; the result is that all the commands are executed in the same shell.
  - `{ echo "First: $BASH_SUBSHELL"; { echo "Second: $BASH_SUBSHELL"; } } ; echo "Third: $BASH_SUBSHELL"`
- The sequence expansion in format {x..y} expands to all the integers or characters in that sequence.
  <img width="976" height="118" alt="image" src="https://github.com/user-attachments/assets/b15006ad-c307-4428-aee6-c806a9f7e03a" />

### Quoting
- Quoting is used to remove the special meaning of certain characters or words to the shell.
- The following meta-characters must be quoted to prevent them from separating words:
  - `| & ; ( ) < > ! space tab`
- There are three types of quoting in Bash: the escape character, single quotes, and double quotes
- Quoting characters in single quotes (') preserves the literal value of each character within the quotes
- A single quote may not occur between single quotes, even when preceded by a backslash
- Quoting characters with double quotes (“) preserves the literal value of each character with the exception of $, ', \, and when history expansion is enabled, !
- There are several escape sequences that are decoded in the format $'string', where string is replaced by one of the following sequences:
  <img width="1526" height="1352" alt="image" src="https://github.com/user-attachments/assets/574830af-e5db-415b-b70b-8f427d0bde0d" />

### Flow Control
- The ability for Bash and other scripting languages to do the same operation on multiple objects, perform loops, and branch execution path is one of the most powerful aspects of scripting
- Bash uses the following constructs for controlling flow for which commands are executed under specific conditions.
  <img width="600" height="1200" alt="image" src="https://github.com/user-attachments/assets/5e0cff26-5ef1-4eb4-9fdf-70741d792305" />

### For Loops
- Creates empty files in /tmp directory
  ```
  cd /tmp
  for i in {1..15}; do touch dummy_log$i.log; done
  ls *.log
  ```
  
  ```
  for i in dummy_log{6..15}.log; do gzip $i; done
  ls dummmy

- `/tmp$ for (( c=1; c<=5; c++ )); do echo "This is number $c" >> dummy_log$c.log; done`

### Select Statement
- The select command generates a menu from the items in the word list
- `select ip in 192.168.1.1 192.168.1.2 192.168.1.3; do echo "You selected: $ip"; done`
  <img width="976" height="311" alt="image" src="https://github.com/user-attachments/assets/9f1e5b30-f9e2-4ce2-a7cb-8bf54b6809e2" />
  
### Case Statements
- Case statements allow for complex conditional statements and branches of execution to be tested in a way that does not require multiple if statements.
  ```
  case word in
    pattern1)
        statements
    ;;
    pattern2)
        statements
    ;;
    *)
        statements
    ;;
  esac
  ```
- This example uses the previous select statement to do a test for the entry of user input
  ```
  #!/bin/bash

  select ip in 192.168.1.1 192.168.1.2 192.168.1.3
  do 
    case $ip in
  
    192.168.1.1)
  	echo "execute some command on $ip"
    ;;
  
    192.168.1.2)
  	echo "execute some command on $ip"
    ;;
  
    192.168.1.3)
  	echo "execute some other command on $ip"
    ;;
  
    *)
  	echo "default case, unknown"
    ;;
    esac
  
  done
  ```
  
  ### If Statements
  - Conditional statements using if are one of the most common ways to control the execution of a script and perform specific actions based on a condition.
  - The if conditional performs a test, and then executes a list of commands.
    ```
    #!/bin/bash

    select ip in 192.168.1.1 192.168.1.2 192.168.1.3
    do 
      
     if [[ $ip == 192.168.1.1 ]]
      then
        echo "execute some command on $ip"
      
      elif [[ $ip == 192.168.1.2 ]]
      then
        echo "execute some command on $ip"
    
      elif [[ $ip == 192.168.1.3 ]]
      then
        echo "execute some other command on $ip"
    
      else
        echo "default case, unknown"
        break 
      fi
    
    done
    ```

### While and Until Loops
- While and until loops are useful for performing a set of tasks while (or until) a certain condition changes
- `i="0"; while (( $i < 5 )); do echo $i; i=$((i+1)); done`


<img width="1728" height="836" alt="image" src="https://github.com/user-attachments/assets/dc3f4db1-2ecd-4819-a0a5-0563bd02e4f3" />

#### Arithmetic Operators
<img width="1104" height="1936" alt="image" src="https://github.com/user-attachments/assets/9d401d40-068b-4009-8d15-80175094adcb" />

#### IF Conditions
<img width="967" height="779" alt="image" src="https://github.com/user-attachments/assets/7d9e70dc-ff93-4926-8e46-1bd904f7800d" />

#### Operators for Files
<img width="784" height="1200" alt="image" src="https://github.com/user-attachments/assets/3eaa59ea-3c85-4f73-861d-76517b184548" />

#### Positional Parameters
<img width="1904" height="1408" alt="image" src="https://github.com/user-attachments/assets/1bf5b27e-af14-45ae-a91e-72c7655d5826" />


### SSH Scripting
- The ssh command is a client program used for logging into a remote machine over an encrypted network connection and executing commands
- It is done as an interactive session or as part of a script.
- Ssh is immensely valuable to analysts to allow remote access to hosts that are physically separated and those that do not have a physical terminal associated with them.
