# MODULE 8

## Libraries

### Overview
- libraries are resources that contain code and/or data
- Modern desktop and server OSs contain methodologies for loading and managing these libraries
- While libraries are often used for native code that can be referenced via C/C++ or other languages with the ability to bind or link to native libraries, many managed languages and runtimes — such as .NET and Java — also use libraries for shared code or data.
- Libraries are referenced by new programs via a process known as **linking**
- Libraries are linked **statically** or **dynamically**
- **Static linking** copies all the referenced portions of the library into the resulting program image
- **dynamic linking** references the library instead of copying the library.
- Common file extensions for libraries on Linux and Windows:
  <img width="1100" height="335" alt="image" src="https://github.com/user-attachments/assets/11933120-f16d-4190-87a4-48066d2497fb" />

### Static Libraries
- On Windows, libraries that are intended to be **statically linked** use the **.lib** file extension by convention
- Linux prepends these files with lib and the file ending with .a.
- Since static libraries are copied to, and included in, the resulting binary at compile time, updating these libraries generally requires recompiling the program.
- Tradeoffs for static libraries:
  - Each application that references a static library requires the library to be loaded separately.
    - May have performance implications due to being embedded in the application.
    - This often results in larger assembly size, however, less overhead exists for method calls.
  - Application updates require recompilation and distribution of the executable in order to take advantage of security patches in newer versions of the library.
  - Statically linked libraries require modification of the executable to tamper with the functions of the library, making them less susceptible to many library-based attacks.

### Dymanic Libraries
- On Windows, **dynamic libraries** use the **.dll** file extension by convention; **Linux** uses **.so**.
- These libraries are stored externally to the application, so they can be updated independently of the executable that uses them
- In addition to compile-time linking, these libraries can be bound to at runtime
- These libraries are typically unchanged during runtime
- Modern OSs typically only load one copy of a library into system memory, mapping any further calls to the same memory location.
- Tradeoffs for dynamic libraries:
  - Most OSs share memory for each loaded library, meaning some memory savings are achieved for common libraries.
  - Dynamic libraries can be updated independently of the program if binary compatibility is maintained by the new version of the library.
  - Dynamic libraries, and their implementation, can be a source of security issues due to the possibility of an application loading a malicious library — for example, by replacing the original library or abuse of library search order.

### Windows Libraries
- Libraries shared by multiple applications might exist in a specific shared library, like an installation in **C:\Program Files\** or by convention by the library provider.
- Libraries are also found in an application’s directory or in Windows system folders like System32
- On Windows systems, there are various readily available programs to view modules (libraries) loaded by processes including **Process Explorer**, **Process Hacker**, **PowerShell’s Get-Process cmdlet**
- Processes with links to dynamic libraries typically search for libraries in the following ways:
  - Checks if the library is already loaded in memory
  - Checks if knowndlls registry entry exists for the DLLControlled by HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs — intended to speed up access to specific DLLs, however some security implications may exist if an attacker has elevated permissions on the host.
  - Searching through various paths, which can happen in one of several ways:
    - SafeSearch order (determined by the HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\SafeDllSearchMode registry key) enabled by default — the registry key must be both present and set to zero to disable it
    - Legacy Search Order — if SafeSearch is disabled, or if an insecure alternate search method is used, such as with the SearchPath method when SetSearchPathMode is set to disable SafeSearch
- SafeSearch Order:
  - Directory application is located in
  - System directory (typically C:\Windows\System32)
  - 16-bit System directory (typically C:\Windows\System)
  - Windows directory (typically C:\Windows\)
  - Current working directory
  - Directories listed in PATH environment variable
- Legacy Search Order:
  - Directory application is located in and loaded from
  - Current working directory
  - System directory (typically C:\Windows\System32)
  - 16-bit System directory (typically C:\Windows\System)
  - Windows directory (typically C:\Windows\)
  - Directories listed in PATH environment variable

### Examining Libraries
- There are several classes of tools for analyzing libraries and executables, such as:
	- Decompiler: Attempts to reconstruct a library or program executable into source code that can be compiled into the same assembly. 
		- May require formatting and relabeling code in order to be comprehensible.
	- Portable Executable (PE) Header/Metadata Analyzer: Examines the headers and other structures of an assembly to reveal information about the assembly, such as its dependencies and extracting resources from the file.
	- String Analyzer/Dumper: Dumps all strings contained in an assembly for analysis.
	- Disassembler: Breaks down native libraries into readable assembly code for analyzing behavior of a library or executable.
	- Hex Editor: Allows viewing and editing of raw binaries; displays data using hexadecimal. Often contains the ability to view binary as various data formats, such as strings or integers.

### Attacks Involving Libraries
- Dynamic libraries are used to achieve an attacker’s goal, including:
	- Persistence
	- Privilege Escalation
	- Defense Evasion
- The following techniques are used to accomplish one or more of the above tactics: 
	- T1546.10: Event Triggered Execution: AppInit DLLs 
		- Causes a library to be loaded any time an application that references User32.dll is executed, which encompasses most applications — allowing persistence.
  		- DllMain entries are used to execute code under that application’s context, which potentially allows for privilege escalation. 
	- T1055.001: Process Injection: DLL Injection
		- DLL Injection: Attach to another process, then load a specified library — triggering the execution of code under that process’s context.
  		- This allows for privilege escalation and some amount of defense evasion. 
	- T1574.002: Hijack Execution Flow: DLL Side-Loading 
		- DLL Side-Loading: Application manifest files describe the version of a library that is loaded.
  		- If this manifest is vague or imprecise, an attacker can exploit this weakness to load a malicious library instead of the intended library.
    	- This allows an attacker to gain persistence by hijacking a common process, some defense evasion by its nature of executing under a trusted process, and a potential for privilege escalation if the process has elevated permissions.
		- T1574.001: Hijack Execution Flow: DLL Search Order Hijacking
			- Hijack Execution Flow: DLL Load Order attack takes advantage of weaknesses in some applications and the order of paths those libraries are loaded from.
   			- An attacker creates a malicious DLL that replaces a DLL expected by the application and executes code under the context of that application, allowing the attacker to potentially become persistent, escalate privileges, or evade defenses.
		- T1574.006: Hijack Execution Flow: LD_PRELOAD 
			- LD_PRELOAD: A shared library attack for Linux that allows an attacker to override which library loads when a process loads a specific library by setting the LD_PRELOAD environment variable

### Detection
- Detection for each of these techniques typically involves the detection of libraries being loaded from unusual locations
- The installation of monitoring software is often necessary to detect these attacks, however, some of these methods leave behind artifacts — especially if in current use for persistence — such as:
	-  T1546.010: AppInit DLL
		- Registry entries, such as HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs
		- Malicious library in the path it is loaded from
	- T1055.001: DLL Injection
		- Malicious library or libraries used during the attack
		- Loaded by processes 
	- T1574.002: DLL Side-Loading 
		- Malicious library or libraries used during the attack in C:\Windows\WinSXS folder 
		- Library manifests in C:\Windows\WinSXS folder 
	- T1547.004: DLL Load Order
		- Malicious library in a search path
	- T1574.006: LD_PRELOAD
		- Malicious library used during the attack
		- Persistent environmental variable change to the LD_PRELOAD variable
- Detection of currently loaded malicious libraries is accomplished by querying modules loaded by processes on the system and analyzing them

## Processes

### Windows Processes
- What is a Windows Process?
	- A process is an executing program — typically based on the Portable Execution (PE) file format — isolated from other running programs on the same system
	- a process is a container that stores all the necessary components for executing a program independently from other programs.
	- A process has numerous elements including:
		- A private virtual memory space
  		- An executable program image
		- Handles to kernel objects
		- A security token
  		- A unique Process Identifier (PID)
		- One or more threads to execute instructions

- Virtual Memory Space
	- In Windows, memory space is divided into an area that user-mode processes access and a second area that is used exclusively by the kernel and kernel processes.
 	- The user mode virtual memory space is further divided between running processes
  	- Each process’s user mode virtual memory space is private to that process; no processes are able to directly access another process’s virtual memory space.
  	- However, such interference is possible through the Windows Application Programming Interface (API)
  	- In contrast, kernel mode memory is shared by all processes on the system since there is only one kernel.
  	- NOTE: Virtual memory is the modern OS’s representation of contiguous blocks of memory, whereas behind the scenes the processor is rapidly interchanging the data in use by Windows processes between Random Access Memory (RAM) and physical memory storage locations on the hard disk. These interchanges are seamless and transparent to the user, and allow larger programs to both become feasible and run faster.
  	- In 32-bit systems, each process is allocated 2 Gigabytes (GB) for its user-mode memory space while the kernel gets 2GB shared across all processes.
  	- In 64-bit systems, each process can theoretically be allocated Terabytes (TB) of user-mode memory space while the kernel also gets TBs of memory space across all processes.
  	- This allocation is possible, even for systems that have a limited amount of RAM, through a process known as virtual memory mapping
  	- each process sees the same range of memory addresses, but those addresses do not necessarily represent the real memory addresses in the computer’s physical RAM.
  	- Processes, however, treat virtual memory addresses as though they were physical memory addresses.
  	- The Windows Memory Manager, part of the kernel space Executive, decides where each process’s data is mapped in the computer’s physical RAM, or if it is stored on the computer’s hard drive in a process known as **Paging**.
  	- The Windows Executive refers to the layer of kernel-mode components that provide a variety of services to device drivers, such as the management of objects, memory, processes and threads, inputs and outputs, and configurations.
  	- **Paging** is the process by which Windows stores infrequently accessed information for processes on a system’s hard drive — in what is known as a **paging file** — freeing up space in the computer’s physical RAM.
  	- When a process needs to access information stored in the paging file, a page fault occurs and Windows loads the necessary data from the page file into RAM.

  	  <img width="504" height="466" alt="image" src="https://github.com/user-attachments/assets/371ed8ee-900e-4e10-bd2e-ea710d983404" />
	  
	- Modern Windows processes take advantage of Address Space Layout Randomization (ASLR).
 		- ASLR is a security mechanism that instructs the Windows loader randomize the base memory address of executables and the position of libraries, heap, and the stack in a processes' address space
   		- ASLR is primarily intended to defend against memory-based exploits like buffer overflows by eliminating an exploit’s ability to rely on hardcoded memory addresses.
     	- ASLR does not defeat memory based exploits or attacks, but increases the difficulty to reliably gain control of execution, reducing the likelihood of a successful attack.
	- The **stack** is an area of memory determined at compile time, and is used as storage for temporary variables and functions used by a program.
 	- The **heap**, in contrast, is used to store data that is provided to the process at runtime because the developer cannot anticipate exactly what information is input into the program in advance.
  	- Memory used by variables and functions stored in the stack is freed by the system automatically, whereas memory allocated on the heap must be specifically freed by the developer that coded the program.
  	- Notably, in the interest of being memory efficient, system Dynamic Link Libraries (DLL) are shared between processes and commonly mapped to the same locations in virtual memory.

- Handles to Kernel Objects
	- Kernel objects are, generally speaking, the system elements Windows exposes to user processes to allow them to perform a wide array of actions within the system.
 	- Example actions include:
  		- Creating a window
	    - Outputting text to the screen
	    - Creating, reading, editing, or deleting a file
	- A **handle** is a reference to a resource.
 		- A process maintains a table of handles so it can access other resources on the system.
		- In the case of kernel objects, handles are how programs are able to identify kernel elements and send instructions for performing the actions mentioned above.
		- Handles are often used in conjunction with Windows API calls to access the details of a process, thread, or file.
	- When a handle for a kernel object is sought, the Executive’s object manager instantiates the requested kernel object.
 	- Kernel objects maintain a reference counter, which keeps track of how many processes are interacting with it.

- Security Token
	- When a user logs into Windows, the system generates and associates a security token with that user account.
 	- Each process that user starts receives the security token, which includes the identity and privileges of the user account.
  	- Windows uses the process’s security token to determine whether it is allowed to interact with a given resource, such as a file, or engaged in a privileged act.
  	- Security tokens contain a range of information, such as:
  		- the Security Identifier (SID) of the originating user account
		- the SIDs for the groups which the account is a member
		- a list of privileges held by that user or that user’s groups.

- Unique PID
	- Each process, when it is created, receives a unique PID.
	- A PID can be used to locate a running process and create a handle to it, like a kernel object.
	- A process’s Identifier (ID) is unique only so long as the process is running.
	- Terminated processes free their IDs, which can then be used by other new processes on the system.

### Windows Threads
- What is a Windows Thread?
	- A thread is a type of entity within a process that actually executes instructions within a process
 	- Without at least one thread, processes are unable to function, and modern Windows processes typically have multiple threads at any given time.
	- Each created process starts with one primary thread, which may then spawn additional threads.
	- Each thread shares the process’s virtual memory space and system resources with other threads.
 	- A thread has multiple components:
  		- **Memory**
    		- Each new thread receives its own memory stack which it uses to store local variables and return addresses of functions it calls.
			- Memory can also be dynamically allocated by a thread, which would be in the process’s heap;
			- dynamic memory is shared between threads, while the stack memory is not.
	    - **Execution context**
     		- A thread’s context stores all the information the thread needs to execute its instructions, such as the value registers contained in the Instruction Pointer (Extended Instruction Pointer [EIP] on 32-bit systems and Return Instruction Pointer [RIP] on 64-bit systems).
       		- Because a Central Processing Unit (CPU) core can only execute one instruction from a thread at a time, processors need to switch between executing different threads frequently.
         	- The execution context is important because the OS is constantly switching between executing different threads — even across different processes.
			- The context allows the thread to pick up where it left off while the OS allows it to continue its execution.
			- Windows uses a mechanism called **Scheduling** to decide which threads to pause and which threads to allow to execute.
	    - **Thread local storage**
     		- TLS provides a mechanism for a thread to store data relevant only to it — without needing to share that information across other threads.
	    - **Security toke**n
     		- By default, a thread inherits the security token held by the process in which it spawns.
			- However, threads also have the ability to impersonate another account, which allows them to access resources and perform privileged actions within the impersonated user’s security context.
			- The token, which the thread inherits, is known as the primary token and, if impersonating another user’s security context, it also has an impersonation token.
	    - **Message queue**
     		- If a thread is intended to perform GUI actions, it has a message queue for receiving any events associated with its User Interface (UI).
	    - **Thread ID**
     		- Like processes, threads also have unique IDs that other applications can use to identify specific threads and create handles pointing to them.
         	- A thread ID is only unique for as long as a thread exists; once a thread has finished executing, its ID is relinquished and can be reused by the system for a new thread.
	    - State
     		- Some states include
       			- **Ready** (meaning the thread is available for the OS to execute it)
				- **Standby** (meaning the thread has been selected as the next thread to execute)
				- **Wait** (meaning the thread is currently paused and waiting for an operation to complete or a resource to become free)
				- **Running** (meaning the thread is currently executing).
	    - Priority
     		-  Priorities rank from **Lowest** to **Highest** with categories like **AboveNormal** and **BelowNormal** in-between.
			-  By default, threads have the Normal priority, which is right in the middle, but that can be modified programmatically.
			-  Threads are scheduled for execution based on their priority. 

### Standard Windows Processes
- **System**: This is the process from which all other processes are initiated and is responsible for system memory and memory management in the Windows kernel. It is always PID 4 — any other PID is suspect.
- **System Idle Process**: This process is simply a measure of how much free processor time is available.
	- The amount of CPU time the system idle process is not occupying determines how much processing capability is currently applied to run actual tasks.
- **Session Manager Subsystem - smss.exe**:
	- This is a startup process activated by the main System process that
 		- creates environment variables
		- starts the kernel and user modes of the Win32 subsystem
		- creates Disk Operating System (DOS) device mappings
		- creates virtual memory paging files
		- starts the Windows login manager.
- **Client Server Runtime Subsystem - csrss.exe**: This critical system process is a user-mode system service in the Win32 subsystem, which is primarily responsible for Win32 console handling and GUI shutdown.
- **Windows Initialization - wininit.exe**:
	- This process launches the Windows initialization procedure, which includes starting the majority of the background applications that are constantly running, such as the **Service Control Manager**, the **Local Security Authority Subsystem Service**, and the **Local Session Manager**.
- **Service Control Manager - services.exe**:
	- This process is a service started at boot that
 		- provides a Remote Procedure Call (RPC) interface for maintaining the database of installed services
		- starting services and driver services either upon system startup or upon demand
		- enumerating installed services and driver services
		- maintaining status information for running services and driver services
		- transmitting control requests to running services
		- locking and unlocking the service database.
- **Local Security Authority Subsystem Service - lsass.exe**:
	- This process is responsible for enforcing security policy on the system, including logon verification, password policy, writing to Windows security logs, and the creation of access tokens.
 	- Credentials are often stored in lsass process memory for use by accounts during a login session.
	- Since it contains those credentials, dumping lsass memory is a valued target of threat actors during the following types of attacks:
- **Service Host Process - svc.exe**:
	- Svchost.exe is a generic host process name for services that run from DLLs.
	- Since DLLs cannot be run directly, the service host process is an executable shell that loads the Windows services libraries and executes them.
	- There are often many svchost.exe entries in a running process list because if a single process was hosting every necessary Windows service, then the failure of that process would cause OS failure. So individual services are started from discrete instances of the service host process.
	- described in MITRE technique ID **T1036.005** Masquerading: Match Legitimate Name or Location.
 - Additionally, due to its role as a host for services running with NT\System level privileges, which are the highest possible privileges in a Windows OS, this process is a frequent target for process injection as well, described in **MITRE technique ID T1055 Process Injection**, or spoofing svchost.exe as a parent PID for a malicious process, described in **MITRE technique ID T1134.004 Access Token Manipulation: Parent PID Spoofing**.
	- Since this process is commonly seen but simultaneously poorly understood by the average user, this process name is a frequent target of masquerade by threat actors to attempt to hide through obfuscation
- **Desktop Windows Manager - dwm.exe**:
	- This process is a compositing window manager that renders a variety of graphical effects such as transparent windows, live taskbar thumbnails, and high-resolution monitor support
	- Windows uses this process to create one composite view of all the windows on the screen before sending it to your monitor.
	- It uses the graphics buffers for each application and composites them together into one view.
	- This prevents the uncertainty of effects that might be caused by applications writing their windows directly to the screen.
- **System Monitor - sysmon64.exe**:
	- While not standard to the Windows OS, this process is a standard endpoint logging application.
	- It is a system service and device driver, and logs all activities dictated in its configuration directly to the Windows Event Log.
	- It logs process creation, network connections, and modifications to file metadata such as creation time.

- **VMware Guest Authentication Service — VGAuthService.exe**: This process is part of the Virtual Machine Software (VMware) tool suite that provides authentication for vSphere guest operations.


- **Microsoft Malware Protection Engine — MsMpEng.exe**: This process is part of the Windows security architecture that checks the system for malware and manages security updates to the system. 


- **Microsoft Office Alternative User Input — ctfmon.exe**: This is the Microsoft process that controls the Office language bar and alternative user inputs — such as through speech or a stylus — or using the onscreen keyboard inputs for foreign languages.


- **Console Windows Host — conhost.exe**
	- This process is a host process for the Windows console, a category of applications that includes the Windows CMD.exe, Windows PowerShell, and other terminals hooking into the Windows console. This is a child process of csrss.exe, which was the host of the Windows console in earlier versions of the Windows OS. Each instance of CMD.exe spawns its own instance of conhost.exe.

- **DLL Launcher — rundll32.exe**
	- This application is used to launch functionality stored in shared DLL files.
	- The valid process is normally located at C:\Windows\System32\rundll32.exe, but sometimes malware uses the same filename and runs from a different directory in order to disguise itself, so determining the executable file path is important if this process is suspect.
	- Additionally, threat actors may abuse the allowlists or false positives from normal operations associated with rundll32.exe to proxy execution of malicious code.
	- By bootstrapping a shared module through rundll32.exe, instead of executing directly, they may avoid defensive mechanism on a system.
	- This method is described further in **MITRE technique ID T1218.011 Signed Binary Proxy Execution: Rundll32.**

- **Windows Explorer — explorer.exe**
	- This process manages the graphical shell component of the Windows OS, which includes the taskbar, Start menu, desktop, file manager, and other OS-wide UI features. As both a highly visible and common process in the Windows OS, the Windows Explorer is a common target during privilege escalation, such as injecting shared library code into Explorer’s memory (MITRE ID T1055.001 Process Injection: Dynamic-link Library Injection) or spoofing explorer.exe as a parent process of a spawned PowerShell session rather than the malicious Office document that an unwitting user opened (MITRE ID T1134.004 Access Token Manipulation: Parent PID Spoofing). Searching for this process during the Discovery phase of post-exploitation allows a threat actor to determine if a user is logged on to the compromised system (MITRE ID T1057 Process Discovery).

-** Memory Compression**: The task of compressing memory for efficient memory management has historically been a role of the System process, but in recent versions of Windows 10 has become the responsibility of the memory compression process. 


- **Sink to Receive Asynchronous Callbacks for WMI Client Application — unsecapp.exe**
	- This process, as part of the WMI subsystem, is a channel for synchronizing information between the system and a remote computer. It is required for any program, service, or driver to interface with the Windows management framework and allows proper responses to requests and instructions from such software.


- **WMI Provider Service — WmiPrvSE.exe**
	- This process performs essential error reporting and monitoring functions, and allows other applications on the computer to request information about the system. The management and monitoring services it provides are useful to some third-party applications. It allows those applications to run tasks and issue commands in a way that Windows understands.


- **DLL Host/Component Object Model (COM) Surrogate — dllhost.exe**
	- This process is designed to launch one or more Windows OSs or applications. It runs a COM object outside the original process that requested it. If the COM object crashes, only the COM surrogate process crashes with it, rather than the requesting host process. If a developer is not fully confident in the code being loaded for an application, that developer likely employs the COM surrogate to host the code.

- **Microsoft Distributed Transaction Coordinator — msdtc.exe**
	- This process is responsible for coordinating distributed transactions requested by client applications that span multiple resource managers across all servers, such as databases, message queues, and file systems.


- **Windows Search — SearchIndexer.exe**
	- This process indexes the Windows file system in order to power the Windows search service and the functions that use it, such as the search boxes in the Start menu and Windows File Explorer.


- **Windows CLI — CMD.exe**: This process is the CLI/terminal itself.

## Windows API

### The Windows API
- The Windows API is the intermediary interface that allows other programs to interact with the Windows OS
- It can be used for many things such as
	- manipulating or creating processes
	- modifying the registry
	- enabling network connections
- It can be thought of as a collection of predefined functions to do everything that needs to be done within the OS
- The API calls referenced are specifically tailored to the need of that attack and used in anomalous fashion.
- The functions that make up the Windows API — and are used to communicate with the Windows OS — are stored and accessed via Windows library files known as DLLs, which can be grouped into categories
- System Services: These libraries provide access to Windows file systems, devices, processes and threads, registry, and error handling.Library DLLs:
	- kernel32.dll
	- advapi32.dll
	- ole32.dll
- Graphics Device Interface: These libraries provide the functionality for outputting graphical content to monitors, printers, and other output devices.
	- Library DLLs:
		- gdi32.dll
- User Interface (UI): These libraries include Common Dialog Box DLLs, which provide functions to create and interface with standard dialog boxes for opening and saving files, choosing color and font, etc.; Common Control Library DLLs, which provide access to status bars, progress bars, toolbars, tabs, and other advanced control features; and Windows Shell DLLs, which provide the functionality and modification of the OS shell.
	- Library DLLs:
		- comctl32.dll
		- comdlg32.dll
		- shell32.dll
		- shlwapi.dll
		- user32.dll
- Network Services: These libraries provide access to the various networking capabilities of the OS, including Network Basic Input/Output System (NetBIOS), Windows Sockets (Winsock), Network Dynamic Data Exchange (NetDDE), Remote Procedure Calls (RPC), and many others.
	- Library DLLs:
		- ws2_32.dll
  		- wsock32.dll
		- wininet.dll
		- netapi32.dll

### API Calls Common in Windows Malware
- **Kernel32.dll**: This is a very common DLL that contains core functionality, such as access and manipulation of memory, files, and hardware. Some of the common API calls in this DLL are:
	- **ConnectNamedPipe**: Creates a server pipe for interprocess communication that waits for a client pipe to connect. Some backdoors and reverse shells use ConnectNamedPipe to simplify or obfuscate connectivity to a Command and Control (C2) server.
	- **CreateFile**: Creates a new file or opens an existing file.
	- **CreateFileMapping**: Creates a handle to a file mapping that loads a file into memory and makes it accessible via memory addresses. Launchers, loaders, and injectors use this to read and modify PE files.
	- **CreateProcess**: Creates and launches a new process. If malware creates a new process, it needs to be analyzed as well.
	- **CreateRemoteThread**: Starts a thread in a remote process. Launchers and stealth malware use CreateRemoteThread to inject code into a different process.
	- **EnumProcesses**: Enumerates through running processes on the system. Malware enumerates through processes to find one into which to inject.
	- **EnumProcessModules**: Enumerates the loaded modules (executables and DLLs) for a given process. Malware enumerates through modules when performing an injection.
	- **GetModuleFilename**: Returns the filename of a module loaded in the current process. Malware uses this function to modify or copy files in the currently running process.
	- **GetModuleHandle**: Obtains a handle to an already loaded module. Processes use GetModuleHandle to locate and modify code in a loaded module or to search for a good location to inject code.
	- **GetProcAddress**: Retrieves the address of a function in a DLL loaded into memory. Imports functions from other DLLs and functions imported in the PE file header.
	- **IsWoW64Process**: Used by a 32-bit process to determine if it is running on a 64-bit OS.
	- **LoadLibraryA/LoadLibraryEx**: Function to load a DLL into a process.
	- **OpenProcess**: Opens a handle to another process running on the system. This handle reads and writes to the other process memory or injects code into the other process.
	- **SetFileTime**: Modifies the creation, access, or last modified time of a file. Malware often uses this function to conceal malicious activity.
	- **VirtualAllocEx**: A routine that allocates memory in a remote process. Malware uses VirtualAllocEx as part of a process injection.
	- **WriteProcessMemory**: Writes data to a remote process. Malware uses WriteProcessMemory as part of a process injection.

- **Advapi32.dll**: This DLL provides access to advanced Windows core components, such as Service Manager and the registry.
	- Some of the common API calls in this DLL are:
		- **AdjustTokenPrivileges**: Enables/disables specific access privileges. It allows malware to gain additional permissions in a process injection attack.
		- **ControlService**: Starts, stops, modifies, or sends a signal to a running service. Code needs to be analyzed that implements malicious services in order to determine the purpose of the call.
		- **CreateService**: Creates a service started at boot time. Malware uses CreateService for persistence, stealth, or to load kernel drivers.
		- **RegCreateKeyEx**: Creates a registry key.
		- **RegDeleteKey**: Deletes a registry subkey and its values.

- **WSock32.dll** and **Ws2_32.dll**: These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks.
	- Some of the common API calls in this DLL are:
		- **Accept**: Listens for incoming connections on a socket. Used by malware to communicate with the C2 server.
		- **Bind**: Associates a local address to a socket to listen for incoming connections.
		- **Connect**: Connects to a remote socket. Malware often uses low-level functionality to connect to a C2 server. Used by malware to communicate with the C2 server.
		- **inet_addr**: Converts an Internet Protocol (IP) address string  — like 127.0.0.1 — to the Windows structure used by other functions, such as Connect. The IP addresses found in these calls — and used in malware —  may be used in network-based signatures to identify potentially malicious activity.
			- NOTE: Not all network activity by malware is useful for signatures as legitimate programs may communicate with the same IP addresses.
		- **Recv**: Receives data from a remote machine. Used by malware to receive data from a remote C2 server.
		- **Send**: Sends data to a remote machine. Used by malware to send data to a remote C2 server.
		- **WSAStartup**: Initializes low-level network functionality. Finding calls to WSAStartup is an easy way to locate the start of network-related functionality.

- **Wininet.dll**: This DLL contains higher-level networking functions that implement protocols such as File Transfer Protocol (FTP), Hypertext Transfer Protocol (HTTP), and Network Time Protocol (NTP).
	- Some of the common API calls in this DLL are:
		- **FtpPutFile**: Uploads a file to remote FTP server.
		- **InternetOpen**: Initializes the high-level internet access functions from Windows Internet (WinINet), such as InternetOpenUrl and InternetReadFile. Searching for InternetOpen is a good way to find the start of internet access functionality. One of the parameters to InternetOpen is the UserAgent, which may be a good network-based signature, if it is unique or not common.
		- **InternetOpenUrl**: Opens a specific Uniform Resource Locator (URL) for a connection using FTP, HTTP, or Hypertext Transfer Protocol Secure (HTTPS). URLs, if fixed, may be good network-based signatures.
		- **InternetReadFile**: Reads data from a previously opened URL.InternetWriteFile: Writes data to a previously opened URL.

- **Ntdll.dll**: The interface to the Windows kernel. Importing this DLL is one way that one can gain access to the undocumented Windows Native API.
	- NOTE: Executables generally do not import this DLL directly, although it is almost always imported indirectly through Kernel32.dll.
	- If this DLL is imported directly, it is a significant red flag for a CDA.
	- It implies that the author of the executable intended to use functionality not normally available to Windows programs.
	- Some tasks, such as hiding functionality of malware or manipulating processes, use this interface.
	- Additional information on many of these attacks is described in the MITRE Adversarial Tactics, Techniques, and Common Knowledge (ATT&CK) Technique ID T1106 Native API.

- Most DLLs require **ntdll.dll** because it contains the system service dispatch instructions for the Windows executive.
- Since user-mode processes have no other way of executing kernel-mode code and objects, **ntdll.dll** is the subsystem necessary to make allowed system calls to the kernel space.
- Most DLLs require **ntdll.dll**, the exceptions being **GDI32.dll** and **User32.dll**, which can make system calls directly to **ntoskrnl.exe** — the Windows kernel.

### Windows API in Malicious/Non-Malicious Contexts
- Each of these API calls exists because they can be and are used for many valid purposes and are commonly employed as such.
- For example:
	- **GetUserName** and GetComputerName are frequently and benignly used to obtain the current context in which a program is running. A piece of malware could use it for information gathering on a newly exploited system.
 - **FindExecutable** is used to obtain the path to a Windows binary that a process relies on as a dependency.
 - **GetTempPath** is used to enable one-off filesystem operations performed by processes, and is also a way for malware to create and hide its on-disk activity.
 - The function **CheckKeyboardBuffer** could be used by normal software to determine whether an expected key was pressed, or it could be used by a piece of malware to peek at what is being typed.
 - The Windows API exists because developers needed a reliable and well-defined method of accessing kernel-level information and objects while writing user-land code

### DLL Injection
- Classic DLL injection is an attack performed by writing the path of a malicious DLL into the virtual address space of a target process, resulting in malicious code execution under the guise of a remote thread created by the target process.
- this type of attack can only be performed in the context of administrator-level permissions.
- This is performed in three steps:

#### Target Selection
- After identifying a process for injection, such as explorer.exe, the malware searches through the existing processes by using the following API calls:
	- **CreateToolhelp32Snapshot**
		- CreateToolhelp32Snapshot is first called to enumerate heap or module states of a specified process or all processes.
	- **Process32First**
 		- Process32First used to iterate through the snapshot structure returned from the first function, each returning information about the enumerated processes
	- **Process32Next**
 		- Process32Next used to iterate through the snapshot structure returned from the first function, each returning information about the enumerated processes
	- **OpenProcess**
 		- Once the malware has received the information for the target process from one of these API calls, it calls OpenProcess to obtain a handle to the target process.

#### Memory Allocation
- Once the handle to a target process is obtained, the malware injects the path to its malicious DLL with the following API calls:
	- **VirtualAllocEx**
 		- VirtualAllocEx creates a virtual memory block large enough to hold a file path in order to have a writeable space inside the target process.
   		- VirtualAllocEx is necessary for this step because prior to writing to a block of memory in a computer, the block must be allocated for use
     	- When a process is allocating additional memory for its own use, it uses the function VirtualAlloc, but when it is allocating space in a different process, VirtualAllocEx is used.
      	- It is important to note that VirtualAlloc and VirtualAllocEx are used to allocate larger scale blocks of memory, not small byte-sized chunks for variables.
      	- For example, if a developer used the line:
      		- `void* pAddress = VirtualAlloc(NULL, 8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);`
      	 - to allocate memory for an 8-byte value, the developer actually allocated an entire page of memory, the size of which varies from system to system, but is often four kilobytes (kb) rather than eight bytes.
 	- **WriteProcessMemory**
  		- The malware then writes the path to the malicious DLL in the allocated memory using WriteProcessMemory.

#### Remote Thread Creation
- Finally, to execute code in the target process, the malware calls one of the following APIs:
	- **CreateRemoteThreadNt**
	- **CreateThreadEx** (undocumented)
	- **RtlCreateUserThread** (undocumented)
- Effectively, executing any one of these functions — by passing the address of the API call LoadLibrary and the address returned from VirtualAllocEx that points to the memory storing the malicious DLL path — successfully results in a remote process that executes the DLL on behalf of the malware.
- NOTE: As remarked above, there are a number of undocumented API calls.
	- These occur when developers internal to Microsoft add functionality to the common libraries but do not intend for their code to be widely accessed.
 - They are undocumented for a number of reasons such as testing, not intended for long term use, or other reasons.
 - These functions are subject to change at any time, and their inputs/outputs are not guaranteed to always be the same.
 - Microsoft provides other functions that are documented as a go-between for the undocumented functions, which are intended for programmers to use.
 - These undocumented functions can still be discovered by dumping the export table of a shared library — usually ntdll.dll — and tracing the functions back to their entry points and conducting a reverse engineering of the assembly code there.
 - Since these functions do not provide an intuitive insight into their function until documentation is developed, they are valued tools of malware developers seeking to obfuscate their tools. That is often an indication of possible maliciousness. 

# MODULE 9

## Registry

### Techniques and Mitigations:
- The MITRE ATT&CK framework details the following techniques specifically associated with the Windows registry:
	- T1012 Query Registry: Through a variety of tools, threat groups access the registry to query for system configuration data to include security credentials, users, permissions, antivirus or host intrusion detection/protection software, and other system profiling data
 		- https://attack.mitre.org/techniques/T1012/
	- T1112 Modify Registry: Through a variety of methods, threat groups interact with the Windows registry to hide configuration information within registry keys, remove information as part of cleaning up, or as part of other techniques to aid in persistence and execution
 		- https://attack.mitre.org/techniques/T1112/
	- T1552.002 Unsecured Credentials: Credentials in Registry: Threat groups search the registry on compromised systems for insecurely stored credentials
 		- https://attack.mitre.org/techniques/T1552/002/
	- T1574.001 Boot or Logon Autostart Execution: Registry Run Keys/Startup Folder: Threat groups modify the registry to achieve persistence by adding a program to a startup folder or referencing it with a registry run key
 		- https://attack.mitre.org/techniques/T1547/001/
	- T1574.011 Hijack Execution Flow: Services Registry Permissions Weakness: Threat groups execute their own malicious payloads by hijacking the registry entries used by services, use flaws in the permissions for registry to redirect from the originally specified executable to one that they control, in order to launch their own code at service start, and change local service configuration information in the registry
 		- https://attack.mitre.org/techniques/T1574/011/
- The key mitigation MITRE ATT&CK has identified is to restrict the registry permissions so that specific permissions are required to modify certain hives or keys in the registry. This is not an absolute mitigation as threat groups often use privilege escalation techniques to gain execution as a user that can modify those restricted keys. Monitoring is essential for critical keys to identify MCA.  
	- M1024 Restrict Registry Permissions: Restrict the ability to modify certain hives or keys in the Windows registryhttps://attack.mitre.org/mitigations/M1024/ 

### Registry Description and Structure
- Registry Description
	- Registry data is read during the following principal events:
		- Initial boot: The boot loader reads the list of boot device drivers to load into memoryKernel boot: The kernel reads settings that specify which device drivers to load and settings for other subsystems (memory manager, process manager, etc.)
		- Log on: During a user’s log on, File Explorer reads per-user settings from the registry (includes drive-letter mappings, wallpaper, screensaver, desktop appearance, etc.)
		- Application startup: Applications read systemwide and per-user settings during startup (can include licenses, menu and toolbar settings, recent documents, and other application settings)
	- Applications and the system may read and update the registry at any time to set and read configuration settings
 	-  Other events that modify the registry include inserting and removing hardware, installing or removing applications, installing or removing device drivers, and changing system settings.

	<img width="1933" height="1887" alt="image" src="https://github.com/user-attachments/assets/34d84bd9-3205-4fff-afe5-b089ec991969" />

- Registry Structure
	- The registry is organized into six root keys, five of which can be accessed via reg.exe (reg) and Registry Editor (regedit).
 	- The sixth, HKEY_PERFORMANCE_DATA, is stored outside the registry, but contains the location of the data and is accessed by querying the RegQueryValueEx Windows API function.

<img width="967" height="746" alt="image" src="https://github.com/user-attachments/assets/e0be5662-3b1e-4d17-8ef8-7e7d205a87eb" />

	- The registry can be visually viewed and changed using regedit as well as from command line programs like reg and PowerShell.
	- Documentation for using reg in batch files can be found by entering reg /? in a command prompt session. 
	- This lesson focuses on manipulating the registry using PowerShell. PowerShell uses the Get-ChildItem cmdlet to query the registry with a path of -PATH Registry::<ROOT KEY>. 
	- PowerShell uses either the root key as specified in Table 9.1-3 or the abbreviation. 
	- Get-ChildItem -Path Registry::HKEY_Current_User and Get-ChildItem -Path Registry::HKCU are both valid syntaxes. 
	- The cmdlet Get-ItemProperty -Path is used for registry keys to return the values for that key. This is different from Get-ChildItem as that cmdlet retrieves the child keys in the specified path.

### HKU and HKCU Root Keys
- The HKU root key contains the profile settings for all users with a profile on the current system, based on their Security Identifier (SID).
	- There is also a subkey for DEFAULT, which is used for processes running under the local system account.
	- If a user logs into the system for the first time and does not have a roaming profile, a profile is created for them based on the profile stored in the %SystemDrive%\Users\Default directory.
- The HKCU root key is a link to the currently logged-in user’s SID key in the HKU root key.
	- It is located on the hard disk at \Users\<username>\Ntuser.dat (older versions of Windows stored user profile information in \Documents and Settings\<username>\NTUSER.dat).
   <img width="967" height="659" alt="image" src="https://github.com/user-attachments/assets/e388b28e-07b1-495d-867a-9dc0774fe902" />

### Common Registry Keys: 
- Commands running when a user logs in:
	- HKLM\Software\Microsoft\Windows\CurrentVersion\Run
	- HKCU\Software\Microsoft\Windows\CurrentVersion\Run
	- HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
	- HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
	- HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnceEx (not created by default on Windows Vista and newer, but can be created by MCAs or system administrators)
	- HKCU\Software\Microsoft\Windows NT\CurrentVersion\Run (legacy; older versions of Windows)
- Refernce programs to run directly or as a dependency:
	- HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
	- HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
	- HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
	- HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
- Used to control automatic startup of services during boot:
	- HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce
	- HKCU\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
	- HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices
	- HKCU\Software\Microsoft\Windows\CurrentVersion\RunServices
- Policy settings set to specify startup programs:
	- HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
	- HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
- Custom actions added to Winlogon key for additional actions occuring for WIN7 or later:
	- HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit
	- HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell
- Programs can be listed in the load value of HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows to load when any user logs on.
- MCAs have also been seen to modify the BootExecute value of HKLM\SYSTEM\CurrentControlSet\Control\Session Manager from the default autocheck autochk * to some other program or process.
- The default value is used for file system integrity checks after an abnormal shutdown. Not all the above keys and values may be present on a system, but may be created by MCA to enable that feature.

- HKLM
	-  The majority of registry keys that are relevant to attackers and defenders are in the HKLM hive.
	-  This root is maintained in memory. On boot-up the kernel loads the keys that are contained in HKLM from disk and creates others dynamically based on the hardware attached to the system.
		<img width="967" height="710" alt="image" src="https://github.com/user-attachments/assets/7679db5a-3d66-4cce-afce-93cdcd315ff8" />

	- The subkeys that have restricted access have restrictions for the **administrator** account and are normally modified under the context of the **SYSTEM** local account
	- The **SYSTEM** local account is used by the OS and services that run under Windows to access Windows internals.
	- The registry entries under the **SAM**, **SECURITY**, and **BCD** keys are modified and changed with specific tools and applications within Windows in order to limit and prevent accidental or intentional configuration changes that may make the system unusable.
	- **regedit** runs with the context of the **SYSTEM** account to view these registry keys, but care should be taken as any changes can make the system unusable.
	- To start regedit in the context of the SYSTEM account, use the **psexec** command from **Sysinternals** with the following command run from a command prompt started as administrator: `psexec -i -s regedit`.
	- The switches start the process interactively (attach the process to a console so you can see the window and use it) and in the SYSTEM account context.
	- Changes that an attacker may make can be detected by watching for changes to the **HKLM\SAM\SAM\DOMAINS\Account\Users\Names\<accountname>** keys (Sysmon Event Identifier [ID] 12).
	- Validating when new users are added and changes to the Local Administrators group (HKLM\SAM\SAM\Domains\Builtin\Aliases\0000220\) can identify rogue accounts and MCA (Sysmon Event ID 13).
	- Windows servers store domain accounts and groups in Active Directory (AD)
 	- The HKLM\SYSTEM key stores system-wide security policies and user-rights assignments and is linked to the HKLM\SAM keys.
	- Both of these keys and their subkeys can be seen in regedit in the SYSTEM account context, but the information is not very useful as it is not in a format meant to be read and understood by humans and is mostly undocumented.
	- The subkeys HKLM\SYSTEM\ControlSet001 and HKLM\SYSTEM\CurrentControlSet refer to specific Windows settings where CurrentControlSet is the currently running settings and not necessarily saved to ControlSet001 (or other number for multiple control sets).
	- Other types of **portable devices** may also be found in the registry in the **HKLM\SOFTWARE\Microsoft\Windows Portable Devices\Devices** key.
	- Windows stores window viewing information (size, view mode, icon, access time, date, etc.) about recently accessed folders and recently accessed documents from the File Explorer in the registry in multiple places
		- HKU\<sid>\Software\Microsoft\Windows\Shell\Bags
		- HKU\<sid>\Software\Microsoft\Windows\Shell\BagMRU
		- HKU\<sid>\Software\Microsoft\Windows\ShellNoRoam\Bags
		- HKU\<sid>\Software\Microsoft\Windows\ShellNoRoam\BagMRU
	- This Key stores local service config settings: **HKLM\SYSTEM\CurrentControlSet\Services**
	- Other programs like Service Control (SC), Windows Management Instrumentation Command-Line (WMIC), and reg can also change the values in this key to affect the execution of services.
	- System administrators do not typically modify the registry entries directly as they use the built-in Windows tools to manage services.
	- Monitoring for unauthorized changes can identify MCAs as services do not have frequent changes.
- You can only interact with **HKU and HKLM** Remotely


## Services

### Windows Services

<img width="538" height="355" alt="image" src="https://github.com/user-attachments/assets/ece18002-8cc8-4eff-b276-281389be42e0" />

- Windows services are applications running in the background of the OS that provide tasks that do not need user interaction.
- This includes implementing **device/driver support**, **networking**, **authentication**, **remote access**, and other hardware-related interfaces.
- Windows services are **user-mode processes** similar to UNIX daemon processes, which are detached from a terminal and **run in the background**
- They can be configured to start at **boot-time**, **manually**, or on an **as-needed basis**, and controlled by other applications like the **Service Control Manager (SCM)**.
- The **SCM** is a special system process — running as **services.exe** — that is responsible for starting, stopping, and interacting with service processes.
- Services are defined in the registry under **HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services**
- Windows Service Control Programs (**SCP**) manage Windows services via the **SCM** using Remote Procedure Calls (**RPC**), through Application Programming Interface (**API**) functions.
- **SCPs** include the services.msc snap-in for the Microsoft Management Console (**MMC**), the CLI utility **sc.exe**, and any **RPC** client calling the appropriate service's API functions
- Service applications must register as a service with the system using the CreateService function.
- The SCM receives messages from the function and creates the appropriate registry keys.
- Registry keys that are associated with the service locations in the registry that have not registered through the CreateService function with the SCM are not actually treated as services.
- Services have three main names, and also can have a description of the service defined in the registry:
	- **Process name**: The name of the running process like svchost.exe, spoolsvc.exe, or mdm.exe (seen using the tasklist /svc, Task Manager, or Process Explorer applications)
	- Internal name: Defined in the registry
	- Display name: Seen in administrative tools (optional; if not defined the internal name is used)
- Windows drivers are also loaded like services, and their configuration details are also housed in the same location in the registry.
- Service device and filesystem drivers are loaded into memory, started using similar Windows function calls, and added and managed by the SCM.
- Service recovery options include:
	- Restart the serivce
	- Restart the computer
	- Run a program
	- Take no action

### SCM
- The SCM is the main orchestrator of Windows services.
- The SCM (services.exe) is started early in the boot process and launches services that have automatic startup configured.
- Services are started based on the registry key **HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder\List**.
- Before the SCM executes the auto-start services, it creates the \Pipe\Ntsvcs RPC named pipe, which is used to interface between the SCM and the SCP.
- After handling the auto-start services, the SCM queues and starts the Automatic (Delayed Start) services.
- These services are not as integral to the early start-up of the OS and typically have dependencies that are in the auto-start group
- There are several reasons multiple services share a single process.
- Each process has some overhead associated with it that takes up system resources.
- Mapping multiple services into a single process saves some of those resources
- One disadvantage to this practice is that if a service in a shared process has errors, which cause the process to exit, all the services in the shared process also terminate.
- Windows has a standard process for hosting services called the Service Host (svchost.exe) process.
- Recall from the earlier tasks, there are multiple svchost.exe processes running, each of them hosting specific services.
- All services that specify svchost.exe -k <sometext> as their image path in the registry share the same process, if the argument <sometext> is the same (e.g., netsvcs).
- The Service Manager application looks similar to other SCPs except it has additional entries for device and filesystem drivers
- Windows services that share a running process are listed as shared, and services that have a standalone process are listed as win32.

### Windows Services Event Logs
- Windows servers log state changes (running, stopped, paused, etc.) for services by default, however, Windows client OSs — like Windows 10 — do not log state changes for services by default.
- Service events are logged in the System log with the Service Control Manager as the source
  <img width="1354" height="1376" alt="image" src="https://github.com/user-attachments/assets/96c3b8f9-7ec6-4321-a878-60b86bbab9b0" />

- Additionally, System Monitor (sysmon) IDs 12 and 13 are associated with the registry, and can be used to monitor for changes to the values associated with services.

### Organizational Certificate Authorities
- Windows uses Public Key Infrastructure (PKI) to authenticate and validate digital certificates.
- Windows domains have many uses for certificates including authentication and authorization.
- An Active Directory (AD) server can be configured with the Certificate Services (AD CS) role to manage issuing and authenticating certificates within a domain or organization.
- The requester (intermediate or end entity) designates the ways a particular certificate can be used.
- The CA signer verifies the request was from the expected entity and signs and issues the certificate.
	 <img width="1936" height="1364" alt="image" src="https://github.com/user-attachments/assets/b0671522-9a6f-48bd-9097-6a675f88498d" />

- The **certsrv** (graphical) and **certutil** (command-line) applications are included by default to assist in managing installed and signed certificates the AD CS server issues.
- Third-Party CAs
	- Third-party CAs are those root certificates that are not issued by Microsoft or the organization, and are the vast majority of the certificates included by default in Windows OSs.

## Windows Logging

### Windows Events
- Windows event logs are the historical record of every major and minor system event.
- Every program that starts on a system posts a notification in an event log, and every well-behaved program posts a notification before it stops.
- Every **system access**, **security change**, **non-standard OS behavior**, **hardware failure**, and **driver malfunction** all end up in one event log or another.
- Event Log Format
	- Modern Windows systems store logs in the **%SystemRoot%\System32\winevt\logs** directory by default in the binary Extensible Markup Language (**XML**) Windows event logging format, designated by the **.evtx** extension
 	- For remote logging, a remote system running the Windows Event Collector service manages subscriptions of logs produced by other systems
  	- The types of logs to be collected can be specified at a granular level and transport occurs over **HTTPS** on port **5986** using **WinRM**
  	- Group Policy Objects (GPO) can be used to configure the remote logging facilities on each computer.
  	- Events can be logged in the **Security**, **System**, and **Application** event logs
  	- The **Setup** event log records activities that occurred during installation of Windows.
  	- The **Forwarded** Logs event log is the default location to record events received from other systems.
  	- These five logs are the default logs for base installations of modern Windows OSs.
  	- By default, Microsoft systems set a maximum log file size at **20480 KB**, and upon reaching that size, it deletes oldest entries first as space is needed to fill the log with more events
  	- Alternative policy options include:
  		- archiving old logs in a separate file to make more space, which eventually creates a hard disk space issue unless the logs are moved elsewhere;
		- changing the log file maximum size, which is still dependent on the amount of disk space available
		- manually clearing logs, which creates an issue with continuous monitoring, as full logs simply do not capture new events.
  	- Event log entries have several fields in common:
		- **Log Name**: The name of the event log where the event is stored. Useful when processing numerous logs pulled from the same system.
		- **Source**: The service, Microsoft component, or application that generated the event.
		- **Event Identifier (ID)**: A code assigned to each type of audited activity. This code is one of the most important fields in an entry, as it is by this code that complex and specific queries can be formed to examine a particular type of behavior.
		- **Level**: The severity assigned to the event in question.
  	- Possible event log severity levels:
  	  
  		<img width="963" height="413" alt="image" src="https://github.com/user-attachments/assets/58ea9ec4-dcc7-4cc2-983c-339f197f7434" />

		- User: The user account involved in triggering the activity or the user context that the source was running as when it logged the event.
  			- Note that this field often indicates System or a user that is not the cause of the event being recorded.
		- Operation Code (OpCode): Assigned by the source generating the log.
			- Its meaning is left to the source.Logged: The local system date and time when the event was logged.
		- Task Category: Assigned by the source generating the log.
  	   		- Its meaning is left to the source.
  	   	- Keywords: Assigned by the source and used to group or sort events.
  	   	- Computer: The computer on which the event was logged.
  	   		- This is useful when examining logs collected from multiple systems, but should not be considered the device that caused an event(such as when a remote logon is initiated, the Computer field still shows the name of the system logging the event, not the source of the connection).
		- Description: A large text block where additional information specific to the event being logged is recorded. This is often the most significant field for the analyst.

### Task Scheduler Logs
- Logs of scheduled tasks can be helpful for assessing recurring behavior on a system.
- Because of the routine predictability of scheduled tasks, they are frequently a method of persistence after threat actors have gained a foothold in a compromised system, as described in **MITRE ID T1053 Scheduled Task/Job**.
- These include regular system tasks, application updates, and routine integrity checks or information pulls by processes.
- If an attacker were to put a routine task on a system, for example to execute a callback to a Command-and-Control (C2) server every day, logs of that kind of task could be found here. A regular inspection of these logs is helpful to identify anomalies.

### PowerShell Logs
- PowerShell logs can be extremely useful data to comb through if a threat adversary is expected to have used PowerShell during a compromise.
- These logs record the commands that were run, the output of the commands, and de-obfuscates any encoded commands, which are common in PowerShell adversarial actions.
- There are three forms of PowerShell logging.
	- Module Logging — Event ID 4103
 		- This policy logs pipeline execution details such as variable initialization, command invocations, some portions of scripts, some de-obfuscated code, and some data formatted for output.
   		- It may not reliably capture the commands executed, but these events record valuable output not captured in other sources.
	- Script Block Logging — Event ID 4104
 		- This policy logs entire blocks of code as they are executed, including scripts and commands.
		- It also records the decoded commands, whether obfuscated with Exclusive Or (XOR), Base64, Rotate by 13 (ROT13), encryption, etc., in addition to the original obfuscated code, as it has access to the decoded commands before the system is able to process them.
		- However, this form of logging does not record output from the executed code.
	- Transcription
		- This policy creates a unique text-based record of every PowerShell session.
		- It writes to a unique session log file with all terminal input and output, exactly as it appears, including the timestamp and metadata for each command.
		- The shortcoming of this form of logging is that the content of any executed scripts or output written to other destinations, such as the file system, is not captured in the transcript.
		- A remote system is the best place to configure this form of logging to write to, so a potential attacker does not have access and is not able to delete them.
- On this system, all three forms of logging are enabled, which is the recommended and highest security setting.
- However, if PowerShell is used frequently on the system, either explicitly or for automated administration tasks, this sort of logging quickly consumes disk space, so a robust archiving or exporting process should be in place.
- Additionally, routinely examining the logs in a timely manner, so that vast amounts of data are not in backlog during a hunt operation, is ideal.

### Events of Interest to DCOs
- Some of the important event IDs are:
	- Account Creation Events
		- **Event 4720** is the event A user account was created. — It is important to investigate such events when no new users are expected on the domain, as creating valid accounts is often a persistence method employed by threat actors.
			- This persistence technique is described in **MITRE Technique T1136: Create Account**.  
		- **Event 4732** is the event A member was added to a security-enabled local group. — This event is important to monitor when a user is added to a local or domain administrator’s group, as this is a method, in combination with user account creation — mentioned above — that threat actors maintain privileged access in a network.
			- This is an addendum to **MITRE Technique T1136: Create Account**,  and is employed to ensure that the persistence maintained includes privileged access to a compromised system.
   
	- Account Logon Events
		- **Event 4624** is the event An account was successfully logged on. — This is generally a good thing, but it is also important to search for evidence of account logins where there should be none. It is important to pay attention to the Message field of these entries, as the Username field does not indicate which user is logging on to the system.
			- The Logon Type field is especially important in this type of event.
   			- This access technique usually follows successful reconnaissance using **MITRE Technique T1589.001: Gather Victim Identity Information: Credentials**. 
		
		<img width="963" height="582" alt="image" src="https://github.com/user-attachments/assets/036f48c9-26b2-405f-a293-4c56409dd73d" />

	- **Event 4625** is the event An account failed to log on. — This is the opposite and analogous case of 4624. A number of these logs in short succession on the same accounts is indicative of a brute force password attack in progress.
		- There are a number of codes indicating why the logon failed that help with analysis of these events. The most useful code in detecting a brute force attack is **0xC000006A**, in occurs when a threat actor attempts numerous wrong passwords against a valid user account.
		- This credential access technique is described in **MITRE Technique T1110: Brute Force**. 

<img width="963" height="837" alt="image" src="https://github.com/user-attachments/assets/c0de7159-2c8a-4681-9513-acf2f25fa882" />
- **Event 4672** is the event Special privileges assigned to new logon. — This event indicates that a user in a highly privileged group, such as local or domain administrators, has logged on and given the appropriate privileges to their logon session. If an adversary has obtained an administrator-level account, this event indicate those logins, so finding these events with an unauthorized administrator account is indicative of privileged adversary persistence in the network.
	- This access technique usually follows successful reconnaissance to obtain administrator credentials using **MITRE Technique T1589.001: Gather Victim Identity Information: Credentials**.  

- Other Windows Internals Events
- **Event 7030** is the event Service is marked as an interactive service. — This event triggers when the system is configured to not allow interactive services, so that the service may not function properly. This event may fire when an adversary attempts to install a service as a persistence mechanism but did not realize that the host did not allow such a service.
	- This persistence or privilege escalation technique is described in **MITRE Technique T1543.003: Create or Modify System Process: Windows Service**.  

- **Event 7045** is the event A new service was installed. — This event indicates a successful installation of a Windows service, which is a routine event. However, when MCA is suspected, each of these event should be investigated to determine if the installed service is benign.
	- The most relevant information to pay attention to in examining these logs is the Service Name, Service Type, and Service Start Type. Services that start automatically (Service Start Type 2) are highly favored by attackers for persistence.
	- This event also logs when adversaries use the persistence technique is described in **MITRE Technique T1543.003: Create or Modify System Process: Windows Service**.  

<img width="963" height="521" alt="image" src="https://github.com/user-attachments/assets/d442f0ba-cfb8-4ac9-82bd-ce6b0cfbe28e" />

<img width="963" height="448" alt="image" src="https://github.com/user-attachments/assets/1f99bd20-71df-4571-b83f-55a845735c85" />


- **Event 4688** is the event A new process has been created. — This event triggers often and is largely normal operating activity, so in a blind hunt, these logs are more noise than helpful. However, when the malicious process is known, searching for that process in these logs can reveal a great deal of information about how that process was spawned (i.e., potential vulnerabilities exploited) and other processes that were spawned by the malicious process as a parent (i.e., potential behavior post-compromise).
	- This persistence or privilege escalation technique is described in **MITRE Technique T1543: Create or Modify System Process**.

- **Event 4670** is the event Permissions on an object were changed. — This event is indicative of change of permissions on objects such as files, processes, registry, etc. If an attacker takes possession of such objects for privilege escalation or to encrypt/destroy them, this event may fire.
- An example of this event logging is when adversaries use the defense evasion technique described in **MITRE Technique T1222.001: File and Directory Permissions Modification: Windows File and Directory Permissions Modification**.

- **Event 4657** is the event A registry value was modified. — Since the Windows registry is essentially the reference database for settings, data, and important facts that the OS and all applications within its use to function, this event logs often when auditing is enabled, because the registry is constantly being modified. Once MCA is confirmed, and the compromised user or process is identified, filtering these events for that suspect identifier yields important data about what an adversary was attempting to accomplish or what artifacts were left behind.
- This persistence or privilege escalation technique is described in **MITRE Technique T1547.001: Boot or Logon Autostart Execution: Registry Run Keys/Startup Folder**.  

### Creating Custom Views
- Important Event ID's for DCO: 4624, 4625, 4720, 4732, 7030, 7045, 4688, 4670, 4672, 1006, 1007, 4657

### SYSMON LOGGING
- Sysmon is a Windows device driver developed by Sysinternals to provide high-fidelity logging of system activity. It provides more data about changes to the registry, file system, and services than is available in standard Windows logs
- It also logs greater detail about process creation, Domain Name System (DNS) query, and network connection events
- Sysmon was built with the goal of offering detailed cyber security-focused event logs that expose specific attacker tactics or add more detail than native Windows event logs
- Sysmon logs are often preferred by security analysts and incident responders over native Windows event logs that provide similar information. However, Sysmon events are generated and stored in the same fashion as native Windows logs
- Useful Sysmon Events

<img width="963" height="775" alt="image" src="https://github.com/user-attachments/assets/a7393554-fe54-4858-8a66-a1dc2fca0d34" />

	- Other Sysmon events may be useful for more niche purposes, such as identifying specific attacker tactics like named pipe creation (Sysmon ID 17)
